# Telemetry.Metrics Custom Reporter

## Setup

```elixir
Mix.install([:telemetry, :telemetry_metrics, :kino])
```

## Custom Reporter

```elixir
defmodule ETSReporter.Handler do
  def handle_event(event_name, measurements, metadata, metrics: metrics, ets: ets) do
    for metric <- metrics do
      IO.inspect(metric, label: "Processing metric")

      try do
        update_entry(ets, event_name, metric, measurements)
        # IO.inspect(metric, label: "Metric")
        # IO.inspect(value, label: "Value")

        IO.puts("Updates ETS table")
        # IO.inspec(ets)
      rescue
        e ->
          Logger.error("Could not format metric #{inspect(metric)}")
          Logger.error(Exception.format(:error, e, __STACKTRACE__))
      end
    end
  end

  defp update_entry(ets, event_name, %Telemetry.Metrics.Counter{} = metric, measurements) do
    IO.puts("Counter")

    :ets.update_counter(ets, key(event_name, metric), 1, {1, 0})
  end

  defp update_entry(ets, event_name, %Telemetry.Metrics.LastValue{} = metric, measurements) do
    IO.puts("Last Value")
    IO.inspect(measurements)
    value = Map.fetch!(measurements, metric.measurement)

    :ets.insert(ets, {key(event_name, metric), value})
  end

  defp key(event_name, %type{} = metric) do
    (event_name ++ [metric.measurement, type]) |> List.to_tuple()
  end
end
```

## Reporter Process

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule ETSReporter.Server do
  use GenServer

  require Logger

  def start_link(options \\ []) do
    GenServer.start_link(__MODULE__, options)
  end

  @supported_metrics [Telemetry.Metrics.Counter, Telemetry.Metrics.LastValue]
  def init(options) do
    # Fetch our list of metrics
    # While we would ideally support all metrics types, the docs suggest
    # fitlering and warning if there are metrics types we do not support. 
    # This also allows us to show what comes in from our `metrics` list.
    metrics =
      options
      |> Keyword.fetch!(:metrics)
      |> Enum.filter(fn
        %metric_type{} when metric_type in @supported_metrics ->
          true

        %metric_type{} ->
          Logger.warn("We do not current support #{metric_type} metrics")
          false
      end)

    ets = Keyword.fetch!(options, :ets)

    for {event, metrics} <- Enum.group_by(metrics, & &1.event_name) do
      id = {__MODULE__, event, self()}
      IO.inspect(event, label: "Event")
      IO.inspect(metrics, label: "metrics")

      :telemetry.attach(id, event, &ETSReporter.Handler.handle_event/4, metrics: metrics, ets: ets)
    end

    {:ok, metrics}
  end
end
```

## Start our Process

```elixir
# Start our ets table that we will be writing to
ets = :ets.new(:ets_reporter_store, [:set, :public])
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
import Telemetry.Metrics

metrics = [
  counter("test.request.duration"),
  last_value("test.request.duration")
  # summary("test.will_be_ignored")
]

ETSReporter.Server.start_link(metrics: metrics, ets: ets)
```

## Sending Metrics

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
:telemetry.execute(
  [:test, :request],
  %{duration: 132},
  %{}
)

:telemetry.execute(
  [:test, :request],
  %{duration: 231},
  %{}
)
```

```elixir
Kino.ETS.new(ets)
```

```elixir
tab = :ets.new(:counter, [:set, :public])

:ets.update_counter(tab, :one, 4, {1, 3})

:ets.insert(tab, {:two, 4})
:ets.insert(tab, {:two, 6})

:ets.tab2list(tab)
```

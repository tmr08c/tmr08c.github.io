# Telemetry.Metrics Custom Reporter

## Setup

```elixir
Mix.install([:telemetry, :telemetry_metrics, :kino])
```

## Custom Reporter

```elixir
defmodule ETSReporter.Handler do
  def handle_event(event_name, measurements, _metadata, metrics: metrics, ets: ets) do
    for metric <- metrics do
      try do
        update_entry(ets, event_name, metric, measurements)
      rescue
        e ->
          Logger.error("Could not format metric #{inspect(metric)}")
          Logger.error(Exception.format(:error, e, __STACKTRACE__))
      end
    end
  end

  defp update_entry(ets, event_name, %Telemetry.Metrics.Counter{} = metric, _measurements) do
    :ets.update_counter(ets, key(event_name, metric), 1, {1, 0})
  end

  defp update_entry(ets, event_name, %Telemetry.Metrics.LastValue{} = metric, measurements) do
    value = Map.fetch!(measurements, metric.measurement)

    :ets.insert(ets, {key(event_name, metric), value})
  end

  defp key(event_name, %type{} = metric) do
    (event_name ++ [metric.measurement, type]) |> List.to_tuple()
  end
end
```

## Reporter Process

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule ETSReporter.Server do
  use GenServer

  require Logger

  def start_link(options \\ []) do
    GenServer.start_link(__MODULE__, options)
  end

  def get_metrics(server) do
    GenServer.call(server, :get_metrics)
  end

  @supported_metrics [Telemetry.Metrics.Counter, Telemetry.Metrics.LastValue]
  def init(options) do
    # Fetch our list of metrics
    # While we would ideally support all metrics types, we are only implementing
    # a few simple examples for demo purposes. The docs suggest
    # fitlering and warning if there are metrics types we do not support. 
    # This also allows us to show what comes in from our `metrics` list.
    metrics =
      options
      |> Keyword.fetch!(:metrics)
      |> Enum.filter(fn
        %metric_type{} when metric_type in @supported_metrics ->
          true

        %metric_type{} ->
          Logger.warn("We do not current support #{metric_type} metrics")
          false
      end)

    ets = :ets.new(table_name(), [:set, :public])

    for {event, metrics} <- Enum.group_by(metrics, & &1.event_name) do
      id = {__MODULE__, event, self()}
      IO.inspect(event, label: "Event")
      IO.inspect(metrics, label: "metrics")

      :telemetry.attach(
        id,
        event,
        &ETSReporter.Handler.handle_event/4,
        metrics: metrics,
        ets: ets
      )
    end

    {:ok, %{metrics: metrics, ets: ets}}
  end

  def handle_call(:get_metrics, _, %{ets: ets} = state) do
    {:reply, ets, state}
  end

  defp table_name() do
    "#{__MODULE__}_#{System.os_time(:second)}" |> String.downcase() |> String.to_atom()
  end
end
```

## Start our Process

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
import Telemetry.Metrics

metrics = [
  counter("test.request.duration"),
  last_value("test.request.duration")
  # summary("test.will_be_ignored")
]

{:ok, server} = ETSReporter.Server.start_link(metrics: metrics)
```

```elixir
ETSReporter.Server.get_metrics(server)
```

## Sending Metrics

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
:telemetry.execute(
  [:test, :request],
  %{duration: 132},
  %{}
)
```

```elixir
ETSReporter.Server.get_metrics(server)
```

```elixir
:telemetry.execute(
  [:test, :request],
  %{duration: 142},
  %{}
)

:telemetry.execute(
  [:test, :request],
  %{duration: 186},
  %{}
)

:telemetry.execute(
  [:test, :request],
  %{duration: 159},
  %{}
)
```

```elixir
ETSReporter.Server.get_metrics(server)
```

```elixir
tab = :ets.new(:counter, [:set, :public])

:ets.update_counter(tab, :one, 4, {1, 3})

:ets.insert(tab, {:two, 4})
:ets.insert(tab, {:two, 6})

:ets.tab2list(tab)

"#{Test}_#{System.os_time(:second)}" |> String.downcase() |> String.to_atom()
```
